/*
 * This file was autogenerated by TinyMPC on Sat Nov 11 22:48:28 2023
 */

#include <iostream>

#include <tinympc/admm.hpp>
#include <tinympc/tiny_data_workspace.hpp>

using namespace Eigen;
IOFormat CleanFmt(4, 0, ", ", "\n", "[", "]");

#ifdef __cplusplus
extern "C" {
#endif

int main()
{
	int exitflag = 1;
	TinyWorkspace work = *(tiny_data_solver.work); 
	tiny_data_solver.work->Xref = tiny_MatrixNxNh::Zero();
	tiny_data_solver.work->Uref = tiny_MatrixNuNhm1::Zero();
	tiny_data_solver.settings->max_iter = 100;
	tiny_data_solver.settings->en_input_bound = 0;
	tiny_data_solver.settings->en_state_bound = 0;

	tiny_VectorNx x0, x1; // current and next simulation states
	x0 << 1.0, 0, 0, 0;

	int i = 0;
	for (int k = 0; k < 1000; ++k)
	{
			printf("tracking error at step %2d: %.4f\n", k, (x0 - work.Xref.col(1)).norm());
			
			// 1. Update measurement
			work.x.col(0) = x0;

			// 2. Update reference (if needed)

			// 3. Reset dual variables (if needed)
			work.y = tiny_MatrixNuNhm1::Zero();
			work.g = tiny_MatrixNxNh::Zero();

			// 4. Solve MPC problem
			tiny_solve(&tiny_data_solver);

			// std::cout << work.iter << std::endl;
			// std::cout << work.u.col(0).transpose().format(CleanFmt) << std::endl;

			// 5. Simulate forward
			x1 = work.Adyn * x0 + work.Bdyn * work.u.col(0);
			x0 = x1;

			// std::cout << x0.transpose().format(CleanFmt) << std::endl;
	}
}

#ifdef __cplusplus
} /* extern "C" */
#endif
